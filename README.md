创建线程的三种方法
继承Thread类
实现Runnable接口：实现方法run，没有返回值，不会抛异常
实现Callable接口：实现方法call，有返回值，会抛异常

第4种获取线程的方式：线程池(原理类似于银行网点)
=====================================================================================================================
线程池特点
1、降低资源消耗：通过重复利用已创建的线程，降低线程创建和销毁造成的消耗
2、提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行
3、提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
=====================================================================================================================
线程池的7大参数
1、corePoolSize：线程池中的常驻核心线程数
2、maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1
2.1 CPU密集型
 2.1.1 CPU核数+1个线程的线程池
2.2 IO密集型
 2.2.1 第一种：CPU核数*2
 2.2.2 第二种(某大厂公式)：CPU核数/(1-阻塞系数) --> 阻塞系数在0.8~0.9之间
3、keepAliveTime：多余的空闲线程的存活时间
当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余空闲线程会被销毁，直到只剩下corePoolSize个线程为止
4、unit：keepAliveTime的单位
5、workQueue：任务队列，被提交但尚未被执行的任务
6、threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般用默认的即可
7、handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的maximumPoolSize时，如何来拒绝请求执行的runnable的策略
=====================================================================================================================
线程池原理
1、在创建了线程池后，等待提交过来的任务请求。
2、当调用execute()方法添加一个请求任务时，线程池会做如下判断：
 2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务
 2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
 2.3 如果队列满了且正在运行的线程数量小于maximumPoolSize，那么马上创建非核心线程运行这个任务
 2.4 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和策略来执行
3、当一个线程完成任务是，它会从队列中取下一个任务来执行
4、当一个线程无事可做，超过一定的时间(keepAliveTime)，线程池会判断：
如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉了；所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小
=====================================================================================================================
JDK内置的4种拒绝策略
1、AbortPolicy：默认，直接抛出RejectedExecutionException异常，阻止系统正常运行
2、CallerRunsPolicy："调用者运行"一种调节机制，该策略即不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量
3、DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中，尝试再次提交当前任务
4、DiscardPolicy：直接丢弃任务，不予任务处理也不抛出异常。如果允许任务丢失，这是最好的一种方案

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力干涉，那它们都将无法推进下去。
=====================================================================================================================
产生死锁的主要原因：
1、系统资源不足
2、进程运行推进的顺序不合适
3、资源分配不当
=====================================================================================================================
解决死锁：
1、jsp命令定位进程号
2、jstack找到死锁查看

命令
linux    ps -ef | grep xxx   ls -l
window下的java运行程序，也有类似的ps的查看进程的命令，但是目前我们需要查看的只是java
        jps = java ps        jps -l
                             jstack 9636(进程编号)